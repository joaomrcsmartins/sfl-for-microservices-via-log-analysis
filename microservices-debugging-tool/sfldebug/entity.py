from enum import Enum
from typing import Any, List, Optional, Set

from sfldebug.tools.object import extract_field, merge_into_list
import sfldebug.tools.logger as sfl_logger


class EntityType(str, Enum):
    """Enum for the entity type."""
    SERVICE = 'SERVICE'
    METHOD = 'METHOD'


class Entity:
    """Entity base class, requires the name, references to it and its type.

    Params:
        name (str): particular name of the entity
        references (dict[str,List]): dict of references captured belonging to the same entity
        entity_type (EntityType): enum member of EntityType (defaults to EntityType.SERVICE)
        parent_name (str): parent entity name
        children_names (Set[str]): set of children entities names
    """

    def __init__(
        self,
        name: str,
        references: dict[str, List],
        entity_type: EntityType = EntityType.SERVICE
    ) -> None:

        self.name = name
        self.references = references
        self.entity_type = entity_type
        self.parent_name: str = ''
        self.children_names: Set[str] = set()

    def get_properties(self) -> dict:
        """Returns dict with Entity properties.

        Returns:
            dict: entity properties contained in a dict
        """
        return {'name': self.name, 'parent_name': self.parent_name,
                'children_names': self.children_names, 'entity_type': self.entity_type,
                'references': self.references}

    def __hash__(self) -> int:
        return hash(self.name + self.entity_type + self.parent_name)

    def get_number_unique_exec(self) -> int:
        """Get the number of unique executions present in the entity

        Returns:
            int: number of unique executions present in the entity
        """
        if 'default' in self.references:
            # Sum the number of references w/o request, plus the number of request minus 'default'
            return len(self.references['default']) + len(self.references.keys()) - 1
        return len(self.references.keys())

    @classmethod
    def count_references(
            cls,
            references: dict[str, List]
    ) -> int:
        """Get the total number of references present in the entity

        Returns:
            int: the count of references in total
        """
        count = 0
        for key in references:
            count += len(references[key])
        return count

    @classmethod
    def merge_references(
        cls,
        new_references: dict[str, List],
        old_references: dict[str, List]
    ) -> None:
        """Merge two sets of references.
        First collected the missing references by fetching the keys present in the old set of
        references and not in the new.
        Then collect the merged references, which are references for the same request_id, that need
        to be merged into a single list.
        Finally update the new set with the references collected.


        Args:
            new_references (dict[str, List]): The references to be updated
            old_references (dict[str,List]): The references to be merged into the new set
        """
        # references of the same entity that are related to different requests
        missing_references = {k: old_references.get(
            k) for k in old_references.keys() - new_references.keys()}

        # references of the same entity that are related to the same request
        merged_references = {k: merge_into_list(new_references.get(k), old_references.get(
            k)) for k in new_references.keys() & old_references.keys()}
        # add missing references to the stored entity
        new_references.update(missing_references)  # type: ignore
        new_references.update(merged_references)


class ServiceEntity(Entity):
    """ServiceEntity subclass of Entity, specific to service entities.
    The arguments in the constructor are used to create a reference to the entity.

    Args:
        request_id (Optional[str]): correlation id generated by the request
        endpoint (Optional[str]): endpoint of the resource targeted in the service
        instance_ip (Optional[str]): IP address of the instance where the service is running
        span_id (Optional[str]): ID of the span where the service is currently running
        parent_span_id (Optional[str]): ID of the parent span of the service who
        invoked the current service
        http_code (Optional[int]): HTTP code relative to the request
        user (Optional[str]): username or id to identify the client who started the request
    """

    def __init__(
        self,
        name: str,
        request_id: Optional[str],
        endpoint: Optional[str],
        instance_ip: Optional[str],
        span_id: Optional[str],
        parent_span_id: Optional[str],
        http_code: Optional[int],
        user: Optional[str]
    ) -> None:

        references: dict[str, List] = {}
        if request_id is None:
            request_id = 'default'
        references[request_id] = [{
            'request_id': request_id,
            'endpoint': endpoint,
            'instance_ip': instance_ip,
            'span_id': span_id,
            'parent_span_id': parent_span_id,
            'http_code': http_code,
            'user': user
        }]
        Entity.__init__(self, name, references, EntityType.SERVICE)


class MethodEntity(Entity):
    """MethodEntity subclass of Entity, specific to method entities.
    The arguments in the constructor are used to create a reference to the entity.

    Args:
        request_id (Optional[str]): correlation id generated by the request
        timestamp (Optional[str]): timestamp string of the logged entity, formatted in ISO8601
        log_level (Optional[str]): level of the log
        message (Optional[str]): logged message
        method_invocation (dict): invocation of a methods, specifying the file, class and method
        names.
    """

    def __init__(
        self,
        name: str,
        request_id: Optional[str],
        timestamp: Optional[str],
        log_level: Optional[str],
        message: Optional[str],
        method_invocation: dict
    ) -> None:

        references: dict[str, List] = {}
        if request_id is None:
            request_id = 'default'
        references[request_id] = [{
            'request_id': request_id,
            'timestamp': timestamp,
            'log_level': log_level,
            'message': message,
            'method_invocation': method_invocation,
        }]
        Entity.__init__(self, name, references, EntityType.METHOD)


def build_entity(log_data: Any) -> Set[Entity]:
    """Generates and returns the entities present in log object.
    Each log object refers to a entity, with more or less specificity.

    If an entity misses required arguments, return empty set or only service entity,
    when possible.

    Ex.: if the log points to a method, generate method and service entities.
    If the log points to a service, generate only a service entity.

    Args:
        log_data (Any): log content formatted in an object

    Returns:
        Set[Entity]: set of entities generated from parsing the log data
    """
    correlation_id: Optional[str] = extract_field('correlationID', log_data)
    # Extract required fields
    microservice_name: Optional[str] = extract_field(
        'microserviceName', log_data)
    if microservice_name is None:
        sfl_logger.logger.warning(('Required microservice name is missing.'
                                   ' Skipping service entity creation.'))
        return set()

    # Create service entity and extract service specific fields
    endpoint = extract_field('endpoint', log_data)
    instance_ip = extract_field('instanceIP', log_data)
    span_id = extract_field('spanID', log_data)
    parent_span_id = extract_field('parentSpanID', log_data)
    http_code = extract_field('httpCode', log_data)
    user = extract_field('user', log_data)
    service_entity = ServiceEntity(microservice_name, correlation_id,
                                   endpoint, instance_ip, span_id, parent_span_id, http_code, user)
    sfl_logger.logger.debug('Created Service Entity for microservice "%s" in request "%s".',
                            microservice_name, correlation_id)

    entities = set()

    # Create a method entity and extract method specific fields
    method_entity: MethodEntity
    method_invocation = extract_field('methodInvocation', log_data)
    if method_invocation is not None:
        method_name: Optional[str] = extract_field(
            'methodName', method_invocation)
        timestamp = extract_field('timestamp', log_data)
        log_level = extract_field('logLevel', log_data)
        message = extract_field('message', log_data)
        try:
            if method_name is None:
                raise NameError(
                    'method_name not present in: {}'.format(log_data))

            method_entity = MethodEntity(
                method_name, correlation_id, timestamp, log_level, message, method_invocation)
            service_entity.children_names.add(method_entity.name)
            sfl_logger.logger.debug('Created Method Entity for method "%s" in request "%s".',
                                    method_name, correlation_id)

            method_entity.parent_name = service_entity.name
            entities.add(method_entity)
        except NameError as err:
            sfl_logger.logger.error('Name Error caught: %s.', err)
            sfl_logger.logger.warning(('Missing method name in request "%s" in service "%s". '
                                       'Skipping method entity creation.'),
                                      correlation_id, microservice_name)

    entities.add(service_entity)
    return entities


def parse_unique_entities(entities: Set[Entity]) -> Set[Entity]:
    """Merge references to the same entities and return the set of unique entity references.
    Two references belong to the same entity if they have the same request id, entity type and name.

    Args:
        entities (Set[Entity]): set of captured entities in the logs

    Returns:
        Set[Entity]: parsed set of entities contain a reference per unique entity
    """

    unique_entities = {}

    for entity in entities:
        unique_hash = entity.__hash__()
        entity_present = unique_hash in unique_entities
        if entity_present:

            updated_entity = merge_entity(entity, unique_entities[unique_hash])
            unique_entities[unique_hash] = updated_entity

        else:
            unique_entities[unique_hash] = entity

    sfl_logger.logger.info(('Merged entity references. ''Number of entities before merging: %d. '
                            'Number of entities post merging: %d.'),
                           len(entities), len(unique_entities))
    return set(unique_entities.values())


def merge_entity(
    new_entity: Entity,
    old_entity: Entity
) -> Entity:
    """Merge entities, by adding the old entities' attributes to the new.

    Args:
        new_entity (Entity): the new entity to be merged
        old_entity (Entity): the old entity to be merged

    Returns:
        Entity: the entity resulting of merging the input entities
    """
    Entity.merge_references(new_entity.references, old_entity.references)
    new_entity.children_names.update(old_entity.children_names)

    return new_entity
