from __future__ import annotations
from enum import Enum
from typing import Any, List, Set

from sfldebug.tools.object import extract_field, merge_attributes


class EntityType(str, Enum):
    """Enum for the entity type."""
    SERVICE = 'SERVICE'
    METHOD = 'METHOD'


class Entity:
    """Entity base class, requires the request id (correlation), a name, and its type.

    Params:
        request_id (str): correlation id generated by the request
        name (str): particular name of the entity
        type (EntityType): enum member of EntityType
        parent_name (str): parent entity name
        children_names (List[str]): list of children entities names
    """

    def __init__(self, request_id: str, name: str, entity_type: EntityType = None):
        self.request_id = request_id
        self.name = name
        self.entity_type = entity_type
        self.parent_name: str = ''
        self.children_names: List[str] = []

    def set_parent_name(self, parent_name: str):
        """Setter for the Entity parent name

        Args:
            parent_name (str, optional): Parent entity name to be set.
        """
        self.parent_name = parent_name

    def set_children_names(self, children_names: List[str]):
        """Setter for the Entity children names

        Args:
            children_names (List[str], optional): Children entities names to be set.
        """
        self.children_names = children_names

    def get_properties(self) -> dict:
        """Returns dict with Entity properties.

        Returns:
            dict: entity properties contained in a dict
        """
        return {'name': self.name, 'parent_name': self.parent_name,
                'children_names': self.children_names, 'entity_type': self.entity_type}

    def __hash__(self) -> int:
        return hash(self.request_id + self.name + self.entity_type + self.parent_name)


class ServiceEntity(Entity):
    """ServiceEntity subclass of Entity, specific to service entities.

    Params:
        endpoint (List[str]): endpoint of the resource targeted in the service
        instance_ip (List[str]): IP address of the instance where the service is running
        span_id (List[str]): ID of the span where the service is currently running
        parent_span_id (List[str]): ID of the parent span of the service who
        invoked the current service
        http_code (List[int]): HTTP code relative to the request
        user (List[str]): username or id to identify the client who started the request
    """

    def __init__(self, request_id: str, name: str, endpoint: List[str], instance_ip: List[str],
                 span_id: List[str], parent_span_id: List[str], http_code: List[int],
                 user: List[str]):
        self.endpoint = endpoint
        self.instance_ip = instance_ip
        self.span_id = span_id
        self.parent_span_id = parent_span_id
        self.http_code = http_code
        self.user = user
        Entity.__init__(self, request_id, name, EntityType.SERVICE)

    def get_properties(self) -> dict:
        service_properties = {'endpoint': self.endpoint, 'instance_ip': self.instance_ip,
                              'span_id': self.span_id, 'parent_span_id': self.parent_span_id,
                              'http_code': self.http_code, 'user': self.user, }

        return super().get_properties() | service_properties


class MethodEntity(Entity):
    """MethodEntity subclass of Entity, specific to method entities.

    Params:
        timestamp (List[str]): timestamp string of the logged entity, formatted in ISO8601
        log_level (List[str]): level of the log
        message (List[str]): logged message
        invocation_chain: invocation chain of the methods, starting by the top-level method invoked
    """

    def __init__(self, request_id: str, name: str, timestamp: List[str], log_level: List[str],
                 message: List[str], invocation_chain: List[Any]):
        self.timestamp = timestamp
        self.log_level = log_level
        self.message = message
        self.invocation_chain = invocation_chain
        Entity.__init__(self, request_id, name, EntityType.METHOD)

    def get_properties(self) -> dict:
        method_properties = {'timestamp': self.timestamp, 'log_level': self.log_level,
                             'message': self.message, 'invocation_chain': self.invocation_chain}

        return super().get_properties() | method_properties


def build_entity(log_data: Any) -> Set[Entity]:
    """Generates and returns the entities present in log object.
    Each log object points to a entity, more or less specific.
    Generate a entity object of each type with equal or less specificity.
    Ex.: if the log points to a method, generate method, class, and service entities.
    If the log points to a class, generate class and service entities.

    Args:
        log_data (Any): log content formatted in an object

    Returns:
        Set[Entity]: set of entities generated from parsing the log data
    """
    # Extract required fields
    correlation_id: str = extract_field('correlationID', log_data)
    microservice_name: str = extract_field('microserviceName', log_data)
    if correlation_id is None or microservice_name is None:
        # TODO handle missing required arguments
        raise NameError(
            'correlation_ID or microservice_name not present in: {}'.format(log_data))

    # Create service entity and extract service specific fields
    endpoint = extract_field('endpoint', log_data)
    instance_ip = extract_field('instanceIP', log_data)
    span_id = extract_field('spanID', log_data)
    parent_span_id = extract_field('parentSpanID', log_data)
    http_code = extract_field('httpCode', log_data)
    user = extract_field('user', log_data)
    service_entity = ServiceEntity(correlation_id, microservice_name, [endpoint],
                                   [instance_ip], [span_id], [parent_span_id], [http_code], [user])

    # Create a method entity and extract method specific fields
    method_entity: MethodEntity
    invocation_chain = extract_field('invocationChain', log_data)
    missing_chain = invocation_chain is None
    empty_chain = len(invocation_chain) == 0
    if not missing_chain and not empty_chain:
        method_invoked = invocation_chain[0]
        method_name: str = extract_field('methodName', method_invoked)

        timestamp = extract_field('timestamp', log_data)
        log_level = extract_field('logLevel', log_data)
        message = extract_field('message', log_data)
        method_entity = MethodEntity(correlation_id, method_name,
                                     [timestamp], [log_level], [message], invocation_chain)
    else:
        method_entity = None

    entities = set()
    entities.add(service_entity)
    if method_entity is not None:

        service_entity.children_names.append(method_entity.name)
        method_entity.parent_name = service_entity.name

        entities.add(method_entity)

    return entities


def parse_unique_entities(entities: Set[Entity]) -> Set[Entity]:
    """Merge references to the same entities and return the set of unique entity references.
    Two references belong to the same entity if they have the same request id, entity type and name.
    In each entity store the collection of information that the references contain.

    Args:
        entities (Set[Entity]): set of captured entities in the logs

    Returns:
        Set[Entity]: parsed set of entities contain a reference per unique entity
    """

    unique_entities = {}

    for entity in entities:
        # TODO check if hash is enough to distinguish method entities
        unique_hash = entity.__hash__()
        entity_present = unique_hash in unique_entities
        if entity_present:

            updated_entity = merge_entity(entity, unique_entities[unique_hash])
            unique_entities[unique_hash] = updated_entity

        else:
            unique_entities[unique_hash] = entity

    return set(unique_entities.values())


def merge_service_entity(new_entity: ServiceEntity, old_entity: ServiceEntity) -> Entity:
    """Merge service entities, by creating a new service entity with attributes merged.

    Args:
        new_entity (ServiceEntity): the new service entity to be merged
        old_entity (ServiceEntity): the old service entity to be merged

    Returns:
        Entity: the merged entity resulting of merging the input entities
    """

    new_endpoint = merge_attributes(new_entity.endpoint, old_entity.endpoint)
    new_instance_ip = merge_attributes(
        new_entity.instance_ip, old_entity.instance_ip)
    new_span_id = merge_attributes(new_entity.span_id, old_entity.span_id)
    new_parent_span_id = merge_attributes(
        new_entity.parent_span_id, old_entity.parent_span_id)
    new_http_code = merge_attributes(
        new_entity.http_code, old_entity.http_code)
    new_user = merge_attributes(new_entity.user, old_entity.user)

    request_id = old_entity.request_id
    name = old_entity.name

    new_service_entity = ServiceEntity(request_id, name, new_endpoint, new_instance_ip,
                                       new_span_id, new_parent_span_id, new_http_code, new_user)

    return new_service_entity


def merge_method_entity(new_entity: MethodEntity, old_entity: MethodEntity) -> Entity:
    """Merge method entities, by creating a new method entity with attributes merged.

    Args:
        new_entity (MethodEntity): the new method entity to be merged
        old_entity (MethodEntity): the old method entity to be merged

    Returns:
        Entity: the merged entity resulting of merging the input entities
    """

    new_timestamp = merge_attributes(
        new_entity.timestamp, old_entity.timestamp)
    new_log_level = merge_attributes(
        new_entity.log_level, old_entity.log_level)
    new_message = merge_attributes(new_entity.message, old_entity.message)
    new_invocation_chain = merge_attributes(
        new_entity.invocation_chain, old_entity.invocation_chain)

    request_id = old_entity.request_id
    name = old_entity.name

    new_method_entity = MethodEntity(
        request_id, name, new_timestamp, new_log_level, new_message, new_invocation_chain)

    return new_method_entity


def merge_entity(new_entity: Entity, old_entity: Entity) -> Entity:
    """Merge entities, by creating a new entity with attributes merged.

    Args:
        new_entity (Entity): the new entity to be merged
        old_entity (Entity): the old entity to be merged

    Returns:
        Entity: the entity resulting of merging the input entities
    """
    new_entity: Entity
    if new_entity.entity_type is EntityType.SERVICE:
        new_entity = merge_service_entity(new_entity, old_entity)
    else:
        new_entity = merge_method_entity(new_entity, old_entity)

    children_names = merge_attributes(
        new_entity.children_names, old_entity.children_names)
    new_entity.set_children_names(children_names)

    parent_name = old_entity.parent_name
    new_entity.set_parent_name(parent_name)

    return new_entity
