from __future__ import annotations
from enum import Enum
from typing import Any, List, Set

from sfldebug.tools.object import extract_field, merge_attributes


class EntityType(str, Enum):
    """Enum for the entity type."""
    SERVICE = 'SERVICE'
    METHOD = 'METHOD'


class Entity:
    """Entity base class, requires the request id (correlation), a name, and its type.

    Params:
        request_id (str): correlation id generated by the request
        name (str): particular name of the entity
        references (List[dict]): list of references captured belonging to the same entity
        entity_type (EntityType): enum member of EntityType (defaults to EntityType.SERVICE)
        parent_name (str): parent entity name
        children_names (List[str]): list of children entities names
    """

    def __init__(self, request_id: str, name: str, references: List[dict],
                 entity_type: EntityType = EntityType.SERVICE):
        self.request_id = request_id
        self.name = name
        self.references = references
        self.entity_type = entity_type
        self.parent_name: str = ''
        self.children_names: List[str] = []

    def set_references(self, references: List[dict]):
        """Setter for the Entity references

        Args:
            references (List[dict]): List of references of the entity to be set
        """
        self.references = references

    def set_parent_name(self, parent_name: str):
        """Setter for the Entity parent name

        Args:
            parent_name (str, optional): Parent entity name to be set.
        """
        self.parent_name = parent_name

    def set_children_names(self, children_names: List[str]):
        """Setter for the Entity children names

        Args:
            children_names (List[str], optional): Children entities names to be set.
        """
        self.children_names = children_names

    def get_properties(self) -> dict:
        """Returns dict with Entity properties.

        Returns:
            dict: entity properties contained in a dict
        """
        return {'name': self.name, 'parent_name': self.parent_name,
                'children_names': self.children_names, 'entity_type': self.entity_type,
                'references': self.references}

    def __hash__(self) -> int:
        return hash(self.request_id + self.name + self.entity_type + self.parent_name)


class ServiceEntity(Entity):
    """ServiceEntity subclass of Entity, specific to service entities.
    The arguments in the constructor are used to create a reference to the entity.

    Args:
        endpoint (str): endpoint of the resource targeted in the service
        instance_ip (str): IP address of the instance where the service is running
        span_id (str): ID of the span where the service is currently running
        parent_span_id (str): ID of the parent span of the service who
        invoked the current service
        http_code (int): HTTP code relative to the request
        user (str): username or id to identify the client who started the request
    """

    def __init__(self, request_id: str, name: str, endpoint: str, instance_ip: str,
                 span_id: str, parent_span_id: str, http_code: int,
                 user: str):

        references: List[dict] = [{
            'endpoint': endpoint,
            'instance_ip': instance_ip,
            'span_id': span_id,
            'parent_span_id': parent_span_id,
            'http_code': http_code,
            'user': user
        }]
        Entity.__init__(self, request_id, name, references, EntityType.SERVICE)


class MethodEntity(Entity):
    """MethodEntity subclass of Entity, specific to method entities.
    The arguments in the constructor are used to create a reference to the entity.

    Args:
        timestamp (str): timestamp string of the logged entity, formatted in ISO8601
        log_level (str): level of the log
        message (str): logged message
        method_invocation (dict): invocation of a methods, specifying the file, class and method
        names.
    """

    def __init__(self, request_id: str, name: str, timestamp: str, log_level: str,
                 message: str, method_invocation: dict):
        references: List[dict] = [{
            'timestamp': timestamp,
            'log_level': log_level,
            'message': message,
            'method_invocation': method_invocation,
        }]
        Entity.__init__(self, request_id, name, references, EntityType.METHOD)


def build_entity(log_data: Any) -> Set[Entity]:
    """Generates and returns the entities present in log object.
    Each log object refers to a entity, with more or less specificity.

    Ex.: if the log points to a method, generate method and service entities.
    If the log points to a service, generate only a service entity.

    Args:
        log_data (Any): log content formatted in an object

    Returns:
        Set[Entity]: set of entities generated from parsing the log data
    """
    # Extract required fields
    correlation_id: str = extract_field('correlationID', log_data)
    microservice_name: str = extract_field('microserviceName', log_data)
    if correlation_id is None or microservice_name is None:
        # TODO handle missing required arguments
        raise NameError(
            'correlation_ID or microservice_name not present in: {}'.format(log_data))

    # Create service entity and extract service specific fields
    endpoint = extract_field('endpoint', log_data)
    instance_ip = extract_field('instanceIP', log_data)
    span_id = extract_field('spanID', log_data)
    parent_span_id = extract_field('parentSpanID', log_data)
    http_code = extract_field('httpCode', log_data)
    user = extract_field('user', log_data)
    service_entity = ServiceEntity(correlation_id, microservice_name,
                                   endpoint, instance_ip, span_id, parent_span_id, http_code, user)

    # Create a method entity and extract method specific fields
    method_entity: MethodEntity
    method_invocation = extract_field('methodInvocation', log_data)
    missing_chain = method_invocation is None
    if not missing_chain:
        method_name: str = extract_field('methodName', method_invocation)
        timestamp = extract_field('timestamp', log_data)
        log_level = extract_field('logLevel', log_data)
        message = extract_field('message', log_data)
        method_entity = MethodEntity(
            correlation_id, method_name, timestamp, log_level, message, method_invocation)
    else:
        method_entity = None

    entities = set()
    entities.add(service_entity)
    if method_entity is not None:

        service_entity.children_names.append(method_entity.name)
        method_entity.parent_name = service_entity.name

        entities.add(method_entity)

    return entities


def parse_unique_entities(entities: Set[Entity]) -> Set[Entity]:
    """Merge references to the same entities and return the set of unique entity references.
    Two references belong to the same entity if they have the same request id, entity type and name.

    Args:
        entities (Set[Entity]): set of captured entities in the logs

    Returns:
        Set[Entity]: parsed set of entities contain a reference per unique entity
    """

    unique_entities = {}

    for entity in entities:
        # TODO check if hash is enough to distinguish method entities
        unique_hash = entity.__hash__()
        entity_present = unique_hash in unique_entities
        if entity_present:

            updated_entity = merge_entity(entity, unique_entities[unique_hash])
            unique_entities[unique_hash] = updated_entity

        else:
            unique_entities[unique_hash] = entity

    return set(unique_entities.values())


def merge_entity(new_entity: Entity, old_entity: Entity) -> Entity:
    """Merge entities, by adding the old entities' attributes to the new.

    Args:
        new_entity (Entity): the new entity to be merged
        old_entity (Entity): the old entity to be merged

    Returns:
        Entity: the entity resulting of merging the input entities
    """

    references = merge_attributes(new_entity.references, old_entity.references)
    new_entity.set_references(references)

    children_names = merge_attributes(
        new_entity.children_names, old_entity.children_names)
    new_entity.set_children_names(children_names)

    return new_entity
