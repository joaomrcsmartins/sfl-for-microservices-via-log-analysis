from enum import Enum
from typing import Any, Optional, Set

from sfldebug.tools.object import extract_field
from sfldebug.tools.logger import logger


class EntityType(str, Enum):
    """Enum for the entity type."""
    SERVICE = 'SERVICE'
    METHOD = 'METHOD'


class Entity:
    """Entity base class, requires the name, references to it and its type.

    Params:
        name (str): particular name of the entity
        references (dict[str,dict]): dict of references captured belonging to the same entity
        entity_type (EntityType): enum member of EntityType (defaults to EntityType.SERVICE)
        parent_name (str): parent entity name
        children_names (Set[str]): set of children entities names
    """

    def __init__(
        self,
        name: str,
        references: dict[str, dict],
        entity_type: EntityType = EntityType.SERVICE
    ) -> None:

        self.name = name
        self.references = references
        self.entity_type = entity_type
        self.parent_name: str = ''
        self.children_names: Set[str] = set()

    def get_properties(self) -> dict:
        """Returns dict with Entity properties.

        Returns:
            dict: entity properties contained in a dict
        """
        return {'name': self.name, 'parent_name': self.parent_name,
                'children_names': self.children_names, 'entity_type': self.entity_type,
                'references': self.references}

    def __hash__(self) -> int:
        return hash(self.name + self.entity_type + self.parent_name)


class ServiceEntity(Entity):
    """ServiceEntity subclass of Entity, specific to service entities.
    The arguments in the constructor are used to create a reference to the entity.

    Args:
        request_id (str): correlation id generated by the request
        endpoint (str): endpoint of the resource targeted in the service
        instance_ip (str): IP address of the instance where the service is running
        span_id (str): ID of the span where the service is currently running
        parent_span_id (str): ID of the parent span of the service who
        invoked the current service
        http_code (int): HTTP code relative to the request
        user (str): username or id to identify the client who started the request
    """

    def __init__(
        self,
        name: str,
        request_id: str,
        endpoint: str,
        instance_ip: str,
        span_id: str,
        parent_span_id: str,
        http_code: int,
        user: str
    ) -> None:

        references: dict[str, dict] = {}
        references[request_id] = {
            'request_id': request_id,
            'endpoint': endpoint,
            'instance_ip': instance_ip,
            'span_id': span_id,
            'parent_span_id': parent_span_id,
            'http_code': http_code,
            'user': user
        }
        Entity.__init__(self, name, references, EntityType.SERVICE)


class MethodEntity(Entity):
    """MethodEntity subclass of Entity, specific to method entities.
    The arguments in the constructor are used to create a reference to the entity.

    Args:
        request_id (str): correlation id generated by the request
        timestamp (str): timestamp string of the logged entity, formatted in ISO8601
        log_level (str): level of the log
        message (str): logged message
        method_invocation (dict): invocation of a methods, specifying the file, class and method
        names.
    """

    def __init__(
        self,
        name: str,
        request_id: str,
        timestamp: str,
        log_level: str,
        message: str,
        method_invocation: dict
    ) -> None:

        references: dict[str, dict] = {}
        references[request_id] = {
            'request_id': request_id,
            'timestamp': timestamp,
            'log_level': log_level,
            'message': message,
            'method_invocation': method_invocation,
        }
        Entity.__init__(self, name, references, EntityType.METHOD)


def build_entity(log_data: Any) -> Set[Entity]:
    """Generates and returns the entities present in log object.
    Each log object refers to a entity, with more or less specificity.

    Ex.: if the log points to a method, generate method and service entities.
    If the log points to a service, generate only a service entity.

    Args:
        log_data (Any): log content formatted in an object

    Returns:
        Set[Entity]: set of entities generated from parsing the log data
    """
    # Extract required fields
    correlation_id: Optional[str] = extract_field('correlationID', log_data)
    microservice_name: Optional[str] = extract_field(
        'microserviceName', log_data)
    if correlation_id is None or microservice_name is None:
        # TODO handle missing required arguments
        logger.error(('Required parameters are missing. ''Correlation ID is "%s". '
                      'Microservice name is "%s"'), correlation_id, microservice_name)
        raise NameError(
            'correlation_ID or microservice_name not present in: {}'.format(log_data))

    # Create service entity and extract service specific fields
    endpoint = extract_field('endpoint', log_data)
    instance_ip = extract_field('instanceIP', log_data)
    span_id = extract_field('spanID', log_data)
    parent_span_id = extract_field('parentSpanID', log_data)
    http_code = extract_field('httpCode', log_data)
    user = extract_field('user', log_data)
    service_entity = ServiceEntity(microservice_name, correlation_id,
                                   endpoint, instance_ip, span_id, parent_span_id, http_code, user)
    logger.debug('Created Service Entity for microservice "%s" in request "%s"',
                 microservice_name, correlation_id)

    entities = set()

    # Create a method entity and extract method specific fields
    method_entity: MethodEntity
    method_invocation = extract_field('methodInvocation', log_data)
    if method_invocation is not None:
        method_name: Optional[str] = extract_field(
            'methodName', method_invocation)
        timestamp = extract_field('timestamp', log_data)
        log_level = extract_field('logLevel', log_data)
        message = extract_field('message', log_data)
        if method_name is None:
            # TODO handle missing required arguments
            logger.error(('Missing method name in request "%s" in service "%s"'),
                         correlation_id, microservice_name)
            raise NameError(
                'method_name not present in: {}'.format(log_data))
        method_entity = MethodEntity(
            method_name, correlation_id, timestamp, log_level, message, method_invocation)
        service_entity.children_names.add(method_entity.name)
        logger.debug('Created Method Entity for method "%s" in request "%s"',
                     method_name, correlation_id)

        method_entity.parent_name = service_entity.name
        entities.add(method_entity)

    entities.add(service_entity)
    return entities


def parse_unique_entities(entities: Set[Entity]) -> Set[Entity]:
    """Merge references to the same entities and return the set of unique entity references.
    Two references belong to the same entity if they have the same request id, entity type and name.

    Args:
        entities (Set[Entity]): set of captured entities in the logs

    Returns:
        Set[Entity]: parsed set of entities contain a reference per unique entity
    """

    unique_entities = {}

    for entity in entities:
        # TODO check if hash is enough to distinguish method entities
        unique_hash = entity.__hash__()
        entity_present = unique_hash in unique_entities
        if entity_present:

            updated_entity = merge_entity(entity, unique_entities[unique_hash])
            unique_entities[unique_hash] = updated_entity

        else:
            unique_entities[unique_hash] = entity

    logger.info(('Merged entity references. ''Number of entities before merging: %d. '
                'Number of entities post merging: %d'),
                len(entities), len(unique_entities))
    return set(unique_entities.values())


def merge_entity(
    new_entity: Entity,
    old_entity: Entity
) -> Entity:
    """Merge entities, by adding the old entities' attributes to the new.

    Args:
        new_entity (Entity): the new entity to be merged
        old_entity (Entity): the old entity to be merged

    Returns:
        Entity: the entity resulting of merging the input entities
    """
    new_entity.references.update(old_entity.references)
    new_entity.children_names.update(old_entity.children_names)

    return new_entity
