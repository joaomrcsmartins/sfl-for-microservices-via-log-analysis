from typing import Any, List, Set


class Entity:
    """Entity base class, requires the request id (correlation), a name, and its type.

    Args:
        request_id (str): correlation id generated by the request
        name (str): particular name of the entity
        type (EntityType): enum member of EntityType
        parent (str): parent entity hash
        children (List[str]): list of children entities hashes
    """

    def __init__(self, request_id: str, name: str):
        self.request_id = request_id
        self.name = name
        self.parent: Entity = None
        self.children: List[Entity] = []


class ServiceEntity(Entity):
    """ServiceEntity subclass of Entity, specific to service entities.

    Args:
        endpoint (str): endpoint of the resource targeted in the service
        instance_ip (str): IP address of the instance where the service is running
        span_id (str): ID of the span where the service is currently running
        parent_span_id (str): ID of the parent span of the service who invoked the current service
        http_code (int): HTTP code relative to the request
        user (str): username or id to identify the client who started the request
    """

    def __init__(self, request_id: str, name: str, endpoint: str, instance_ip: str,
                 span_id: str, parent_span_id: str, http_code: int, user: str):
        self.endpoint = endpoint
        self.instance_ip = instance_ip
        self.span_id = span_id
        self.parent_span_id = parent_span_id
        self.http_code = http_code
        self.user = user
        Entity.__init__(self, request_id, name)


class MethodEntity(Entity):
    """MethodEntity subclass of Entity, specific to method entities.

    Args:
        timestamp (str): timestamp string of the logged entity, formatted in ISO8601
        log_level (str): level of the log
        message (str): logged message
        invocation_chain: invocation chain of the methods, starting by the top-level method invoked
    """

    def __init__(self, request_id: str, name: str, timestamp: str, log_level: str,
                 message: str, invocation_chain):
        self.timestamp = timestamp
        self.log_level = log_level
        self.message = message
        self.invocation_chain = invocation_chain
        Entity.__init__(self, request_id, name)


def extract_field(field: str, obj: Any) -> Any | None:
    """Simple field extraction function that returns none if the field is not present in the object.

    Args:
        field (str): name of the field to be extracted
        obj (Any): object to extract the data

    Returns:
        Any|None: returns the contents in the field, if present, or None, if missing
    """
    if field in obj:
        return obj[field]
    else:
        return None


def build_entity(log_data: Any) -> None:  # Set[Entity]:
    """Generates and returns the entities present in log object.
    Each log object points to a entity, more or less specific.
    Generate a entity object of each type with equal or less specificity.
    Ex.: if the log points to a method, generate method, class, and service entities.
    If the log points to a class, generate class and service entities.

    Args:
        log_data (Any): log content formatted in an object

    Returns:
        Set[Entity]: set of entities generated from parsing the log data
    """
    # Extract required fields
    correlation_id: str = extract_field('correlationID', log_data)
    microservice_name: str = extract_field('microserviceName', log_data)
    if correlation_id is None or microservice_name is None:
        # TODO handle missing required arguments
        raise NameError(
            'correlation_ID or microservice_name not present in: {}'.format(log_data))

    # Create service entity and extract service specific fields
    endpoint = extract_field('endpoint', log_data)
    instance_ip = extract_field('instanceIP', log_data)
    span_id = extract_field('spanID', log_data)
    parent_span_id = extract_field('parentSpanID', log_data)
    http_code = extract_field('httpCode', log_data)
    user = extract_field('user', log_data)
    service_entity = ServiceEntity(correlation_id, microservice_name,
                                   endpoint, instance_ip, span_id, parent_span_id, http_code, user)

    # Create a method entity and extract method specific fields
    method_entity: MethodEntity
    invocation_chain = extract_field('invocationChain', log_data)
    missing_chain = invocation_chain is None
    empty_chain = len(invocation_chain) == 0
    if not missing_chain and not empty_chain:
        method_invoked = invocation_chain[0]
        method_name: str = extract_field('methodName', method_invoked)

        timestamp = extract_field('timestamp', log_data)
        log_level = extract_field('logLevel', log_data)
        message = extract_field('message', log_data)
        method_entity = MethodEntity(correlation_id, method_name,
                                     timestamp, log_level, message, invocation_chain)
    else:
        method_entity = None

    entities = set()
    entities.add(service_entity)
    if method_entity is not None:
        service_entity.children.append(method_entity.__hash__())
        method_entity.parent = service_entity.__hash__()

        entities.add(method_entity)

    return entities


def parse_unique_entities(entities: Set[Entity]) -> Set[Entity]:
    """Merge references to the same entities and return the set of unique entity references

    Args:
        entities (Set[Entity]): set of captured entities in the logs

    Returns:
        Set[Entity]: parsed set of entities contain a reference per unique entity
    """
    # TODO aggregate references to the same entities and return the resulting collection
    return entities
